---
phase: 04-installation-safety
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/tools/installationBackup.ts
  - test/tools/installationBackup.test.ts
autonomous: true

must_haves:
  truths:
    - "Backup creates copies of package.json and lock file before installation"
    - "Restore replaces current files with backup copies on failure"
    - "Cleanup removes backup files after successful installation"
    - "Backup handles missing lock file gracefully (new projects)"
    - "Restore is idempotent (safe to call even if backup missing)"
    - "Error formatter produces actionable feedback with package names, error type, and rollback confirmation"
  artifacts:
    - path: "src/tools/installationBackup.ts"
      provides: "BackupState type, createBackup, restoreBackup, cleanupBackup, formatInstallFailureFeedback functions"
      exports: ["BackupState", "createBackup", "restoreBackup", "cleanupBackup", "formatInstallFailureFeedback"]
    - path: "test/tools/installationBackup.test.ts"
      provides: "Unit tests for all backup/restore operations and error formatting"
      min_lines: 80
  key_links:
    - from: "src/tools/installationBackup.ts"
      to: "node:fs"
      via: "copyFileSync, renameSync, unlinkSync, existsSync"
      pattern: "from 'node:fs'"
    - from: "src/tools/installationBackup.ts"
      to: "src/tools/packageManager.ts"
      via: "PackageManager type for lock file resolution"
      pattern: "PackageManager"
    - from: "src/tools/installationBackup.ts"
      to: "src/tools/packageInstaller.ts"
      via: "InstallError type for error formatting"
      pattern: "InstallError"
---

<objective>
Create the installation backup/restore module and install failure feedback formatter with TDD.

Purpose: Provide atomic backup/restore operations for package.json and lock files, plus structured error messages for coder retry on install failure. This is the core safety mechanism for Phase 4.

Output: Tested `installationBackup.ts` module with createBackup, restoreBackup, cleanupBackup, and formatInstallFailureFeedback functions.
</objective>

<execution_context>
@/home/reset/.claude/get-shit-done/workflows/execute-plan.md
@/home/reset/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-installation-safety/04-RESEARCH.md
@src/tools/packageInstaller.ts
@src/tools/packageManager.ts
@src/utils/result.ts
</context>

<feature>
  <name>Installation Backup/Restore and Error Formatting</name>
  <files>src/tools/installationBackup.ts, test/tools/installationBackup.test.ts</files>
  <behavior>
    BackupState type:
    - packageJson: { path: string; backupPath: string }
    - lockFile: { path: string; backupPath: string } | null

    createBackup(projectRoot: string, pm: PackageManager): BackupState
    - Copies package.json to package.json.backup-{timestamp}
    - Copies lock file (npm: package-lock.json, pnpm: pnpm-lock.yaml, yarn: yarn.lock) to {lockfile}.backup-{timestamp} if it exists
    - Returns BackupState with original and backup paths
    - If lock file does not exist, lockFile field is null

    restoreBackup(backup: BackupState): void
    - Renames backup package.json back to package.json (atomic via renameSync)
    - Renames backup lock file back to lock file if lockFile is not null
    - Does nothing (no throw) if backup files don't exist (idempotent)

    cleanupBackup(backup: BackupState): void
    - Deletes backup package.json file
    - Deletes backup lock file if it exists
    - Does nothing (no throw) if backup files already removed

    formatInstallFailureFeedback(packages: string[], error: InstallError, pm: PackageManager): string
    - For install_failed: includes packages, PM, exit code, rollback confirmation, possible causes (typo, version conflict, peer deps, network), action to rewrite without packages
    - For execution_failed: includes PM execution failure, rollback confirmation, action to rewrite
    - For invalid_argument: includes invalid name, action to fix

    Test cases:
    - createBackup: creates backup files, handles missing lock file
    - restoreBackup: restores files, idempotent when backups missing
    - cleanupBackup: removes backups, idempotent when already cleaned
    - formatInstallFailureFeedback: each error type produces correct message with package names, rollback notice, and action items
  </behavior>
  <implementation>
    Use synchronous fs operations (copyFileSync, renameSync, unlinkSync, existsSync) from node:fs.
    Import PackageManager from ./packageManager.js and InstallError from ./packageInstaller.js.
    Lock file mapping: { npm: 'package-lock.json', pnpm: 'pnpm-lock.yaml', yarn: 'yarn.lock' }.
    Backup suffix: `.backup-${Date.now()}` to prevent collision.
    For tests: use node:fs and os.tmpdir() to create real temp directories with real files. No mocking fs - test actual file operations.
    Export all functions and types for pipeline consumption.
    Add barrel export in src/tools/index.ts.
  </implementation>
</feature>

<verification>
- `npx vitest run test/tools/installationBackup.test.ts` passes all tests
- `npx tsc --noEmit` has no type errors
</verification>

<success_criteria>
- createBackup creates backup copies of package.json and lock file
- restoreBackup atomically restores files from backup
- cleanupBackup removes backup files after success
- All edge cases handled (missing lock file, missing backups, double cleanup)
- formatInstallFailureFeedback produces actionable messages for all 3 error types
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-installation-safety/04-01-SUMMARY.md`
</output>
