---
phase: 04-installation-safety
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/orchestrator/pipeline.ts
  - test/orchestrator/pipeline.test.ts
  - src/tools/index.ts
autonomous: true

must_haves:
  truths:
    - "Pipeline creates backup before each installation attempt (prod and dev separately)"
    - "Pipeline restores backup on installation failure"
    - "Pipeline cleans up backup files after successful installation"
    - "Coder receives structured failure feedback including package names, error type, and rollback confirmation"
    - "Successful prod install is preserved when dev install fails (separate backup boundaries)"
  artifacts:
    - path: "src/orchestrator/pipeline.ts"
      provides: "Backup/restore wrapped around installPackages calls with failure feedback to coder"
      contains: "createBackup"
    - path: "test/orchestrator/pipeline.test.ts"
      provides: "Tests for rollback on failure, cleanup on success, and coder failure feedback"
    - path: "src/tools/index.ts"
      provides: "Barrel export for installationBackup module"
  key_links:
    - from: "src/orchestrator/pipeline.ts"
      to: "src/tools/installationBackup.ts"
      via: "Imports createBackup, restoreBackup, cleanupBackup, formatInstallFailureFeedback"
      pattern: "from '../tools/installationBackup.js'"
    - from: "src/orchestrator/pipeline.ts"
      to: "src/tools/packageInstaller.ts"
      via: "Existing installPackages calls now wrapped with backup/restore"
      pattern: "installPackages"
---

<objective>
Wire the backup/restore module into the pipeline's installation flow. Wrap each installPackages() call with createBackup/restoreBackup/cleanupBackup, and send structured failure feedback to coder when installation fails.

Purpose: This completes SAFE-02 by ensuring failed installations trigger rollback and subsequent coder attempts receive actionable feedback about the failure.

Output: Updated pipeline.ts with backup/restore safety and tests covering rollback, cleanup, and failure feedback.
</objective>

<execution_context>
@/home/reset/.claude/get-shit-done/workflows/execute-plan.md
@/home/reset/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-installation-safety/04-RESEARCH.md
@.planning/phases/04-installation-safety/04-01-SUMMARY.md

@src/orchestrator/pipeline.ts
@src/tools/installationBackup.ts
@src/tools/packageInstaller.ts
@test/orchestrator/pipeline.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire backup/restore into pipeline install flow</name>
  <files>src/orchestrator/pipeline.ts, src/tools/index.ts</files>
  <action>
In the pipeline's import validation loop (around lines 266-346), wrap each installPackages() call with backup/restore:

1. **Add imports:** Import `createBackup`, `restoreBackup`, `cleanupBackup`, `formatInstallFailureFeedback` from `../tools/installationBackup.js`.

2. **Declare error tracking variable** before the prod install block:
```typescript
let lastInstallError: import('../tools/packageInstaller.js').InstallError | null = null
```

3. **Wrap production install (around line 283):**
```typescript
if (categorized.production.length > 0) {
  const prodBackup = createBackup(tools.getProjectRoot(), detectedPM)

  const prodResult = await installPackages({
    packageManager: detectedPM,
    packages: categorized.production,
    projectRoot: tools.getProjectRoot(),
    category: 'prod',
  })

  if (prodResult.ok) {
    allInstalled.push(...categorized.production)
    installedProd.push(...categorized.production)
    cleanupBackup(prodBackup)
  } else {
    restoreBackup(prodBackup)
    lastInstallError = prodResult.error
    pipelineLogger.warn(
      { error: prodResult.error.message },
      'Production install failed, rolled back project state'
    )
    registryInvalid.push(...categorized.production)
    installFailed = true
  }
}
```

4. **Wrap dev install (around line 300):**
Same pattern — createBackup before, restoreBackup on failure, cleanupBackup on success. On failure, also set `lastInstallError = devResult.error`.

5. **Add failure feedback to coder:** When `installFailed` is true and `allInstalled.length === 0`, build structured feedback using `formatInstallFailureFeedback()` and trigger coder retry:
```typescript
if (installFailed && allInstalled.length === 0) {
  // All installations failed — send structured feedback to coder
  const failedPkgs = [...categorized.production, ...categorized.dev]
  const feedback = formatInstallFailureFeedback(failedPkgs, lastInstallError, detectedPM)

  codeResult = await coderAgent(
    { ...coderInput, importValidationFeedback: feedback },
    createAgentContext('coder')
  )

  if (!codeResult.ok) {
    errors.push(`Coder failed after install rollback for task ${task.id}: ${codeResult.error.message}`)
    break
  }
}
```

6. **Add barrel export:** Add `export * from './installationBackup.js'` to `src/tools/index.ts`.

Key consideration: Each install category (prod/dev) has its own backup boundary. If prod succeeds but dev fails, only dev is rolled back — prod packages remain installed.
  </action>
  <verify>npx tsc --noEmit -- TypeScript compiles with pipeline changes</verify>
  <done>Pipeline wraps installPackages with backup/restore, cleans up on success, restores on failure, sends structured failure feedback to coder.</done>
</task>

<task type="auto">
  <name>Task 2: Tests for pipeline rollback and failure feedback</name>
  <files>test/orchestrator/pipeline.test.ts</files>
  <action>
Add tests in a new `describe('installation rollback')` block within the existing pipeline tests.

**Setup:** Mock `createBackup`, `restoreBackup`, `cleanupBackup`, `formatInstallFailureFeedback` from installationBackup module using `vi.hoisted()` + `vi.mock()` pattern (same as existing mocks for packageManager, packageRegistry, packageInstaller).

**Tests:**

1. **Test: restoreBackup called on install failure**
   - Mock installPackages to return err for prod install.
   - Verify restoreBackup was called.
   - Verify cleanupBackup was NOT called.

2. **Test: cleanupBackup called on install success**
   - Mock installPackages to return ok.
   - Verify cleanupBackup was called.
   - Verify restoreBackup was NOT called.

3. **Test: separate backup boundaries for prod and dev**
   - Mock: prod install succeeds, dev install fails.
   - Verify createBackup called twice (once for prod, once for dev).
   - Verify cleanupBackup called for prod (success).
   - Verify restoreBackup called for dev (failure).

4. **Test: coder receives failure feedback after rollback**
   - Mock installPackages to fail.
   - Verify coder is retried with importValidationFeedback containing rollback confirmation text.

Run: `npx vitest run test/orchestrator/pipeline.test.ts`
  </action>
  <verify>npx vitest run test/orchestrator/pipeline.test.ts -- all tests pass including new rollback tests</verify>
  <done>Pipeline rollback fully tested: restore on failure, cleanup on success, separate boundaries, and coder failure feedback.</done>
</task>

</tasks>

<verification>
```bash
# Pipeline tests pass
npx vitest run test/orchestrator/pipeline.test.ts

# All project tests pass
npx vitest run

# TypeScript compiles
npx tsc --noEmit
```
</verification>

<success_criteria>
1. Pipeline creates backup before each installPackages call
2. Failed installations trigger restoreBackup to roll back project state
3. Successful installations trigger cleanupBackup to remove backup files
4. Prod and dev have separate backup boundaries (prod success preserved on dev failure)
5. Coder receives structured failure feedback with package names, error type, and rollback confirmation
6. All existing tests still pass
7. New rollback tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-installation-safety/04-02-SUMMARY.md`
</output>
