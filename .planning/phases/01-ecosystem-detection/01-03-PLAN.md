---
phase: 01-ecosystem-detection
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/tools/packageInstaller.ts
  - src/tools/index.ts
  - src/orchestrator/pipeline.ts
  - src/cli/index.ts
  - src/cli/commands/run.ts
  - src/utils/config.ts
  - src/tools/toolkit.ts
  - test/tools/packageInstaller.test.ts
autonomous: true

must_haves:
  truths:
    - "Agent detects package manager and uses it for installation commands"
    - "Packages are validated against npm registry before consent prompt is shown"
    - "User sees install command preview and package names in consent prompt"
    - "Approved packages are installed via single batched command (e.g., pnpm add zod axios)"
    - "Installation output streams to console in real-time"
    - "Failed installations feed error back to coder for rewriting with alternatives"
    - "Rejected packages feed back to coder for rewriting without those packages"
    - "--auto-install flag skips consent prompts for package installation"
    - "After successful install, import validation re-runs to verify imports resolve"
  artifacts:
    - path: "src/tools/packageInstaller.ts"
      provides: "Package installation orchestration"
      exports: ["installPackages", "InstallResult", "InstallError"]
    - path: "src/orchestrator/pipeline.ts"
      provides: "Updated pipeline with dependency installation in import validation loop"
      contains: "installPackages\\|detectPackageManager\\|validatePackage"
    - path: "src/cli/index.ts"
      provides: "CLI with --auto-install flag"
      contains: "auto-install"
  key_links:
    - from: "src/orchestrator/pipeline.ts"
      to: "src/tools/packageManager.ts"
      via: "detectPackageManager() call at pipeline start"
      pattern: "detectPackageManager"
    - from: "src/orchestrator/pipeline.ts"
      to: "src/tools/packageRegistry.ts"
      via: "validatePackageExists() before consent"
      pattern: "validatePackage"
    - from: "src/orchestrator/pipeline.ts"
      to: "src/tools/packageInstaller.ts"
      via: "installPackages() after consent approval"
      pattern: "installPackages"
    - from: "src/tools/packageInstaller.ts"
      to: "node:child_process"
      via: "spawn() for PM execution"
      pattern: "spawn\\("
    - from: "src/cli/commands/run.ts"
      to: "src/orchestrator/pipeline.ts"
      via: "autoInstall option passed through PipelineOptions"
      pattern: "autoInstall"
---

<objective>
Wire package manager detection, registry validation, and installation execution into the pipeline. Add --auto-install CLI flag.

Purpose: This plan connects all Phase 1 components: detection (Plan 01) + registry validation (Plan 02) + installation execution + pipeline integration. After this plan, the agent can detect the project's package manager, validate packages, get consent, install them, and re-verify imports.
Output: Working end-to-end dependency installation flow integrated into the existing pipeline.
</objective>

<execution_context>
@/home/reset/.claude/get-shit-done/workflows/execute-plan.md
@/home/reset/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-ecosystem-detection/01-01-SUMMARY.md
@.planning/phases/01-ecosystem-detection/01-02-SUMMARY.md
@src/orchestrator/pipeline.ts
@src/tools/toolkit.ts
@src/consent/manager.ts
@src/cli/index.ts
@src/cli/commands/run.ts
@src/utils/config.ts
@src/tools/importValidator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PackageInstaller and add --auto-install flag</name>
  <files>src/tools/packageInstaller.ts, src/tools/index.ts, src/cli/index.ts, src/cli/commands/run.ts, src/utils/config.ts, src/tools/toolkit.ts</files>
  <action>
**Step 1: Create `src/tools/packageInstaller.ts`.**

```typescript
import { spawn } from 'node:child_process'
import type { PackageManager } from './packageManager.js'
import type { Result } from '../utils/result.js'
```

Export types:
```typescript
export type InstallResult = {
  success: boolean
  packages: string[]
  packageManager: PackageManager
}

export type InstallError = {
  type: 'install_failed' | 'execution_failed' | 'invalid_argument'
  message: string
  exitCode?: number
}
```

Implement `installPackages(options: { packageManager: PackageManager, packages: string[], projectRoot: string }): Promise<Result<InstallResult, InstallError>>`:

1. Build install args based on PM (per user decision: default caret ranges, batch into one command):
   - npm: `['install', '--save', ...packages]`
   - pnpm: `['add', ...packages]`
   - yarn: `['add', ...packages]`

2. Validate all package name arguments don't contain shell metacharacters (defense in depth - use same SHELL_META regex from toolkit.ts). If any do, return `err({ type: 'invalid_argument' })`.

3. Use `spawn()` (NOT `exec()`, NOT `spawnSync()`) with:
   - `shell: false` (CRITICAL: prevent shell injection per research)
   - `stdio: 'inherit'` (per user decision: show PM output in real-time)
   - `cwd: projectRoot`

4. Return `ok({ success: true, packages, packageManager })` on exit code 0.
5. Return `err({ type: 'install_failed', exitCode, message })` on non-zero exit.
6. Return `err({ type: 'execution_failed', message })` on spawn error (command not found, etc.).

Add export to `src/tools/index.ts`: `export * from './packageInstaller.js'`

**Step 2: Add `--auto-install` CLI flag.**

In `src/cli/index.ts`, add option to the `run` command:
```
.option('--auto-install', 'Automatically install missing packages without prompting', false)
```

In `src/cli/commands/run.ts`:
- Add `autoInstall?: boolean` to `RunOptions`
- Pass `autoInstall` through to `runPipeline()` via `PipelineOptions`

**Step 3: Update PipelineOptions in config.**

In `src/utils/config.ts`, add to `PipelineConfigSchema`:
```typescript
autoInstall: z.boolean().default(false),
```

In `src/orchestrator/pipeline.ts`, add to `PipelineOptions`:
```typescript
autoInstall?: boolean
```

**Step 4: Add 'yarn' to ALLOWED_COMMANDS in toolkit.ts.**

In `src/tools/toolkit.ts`, add `'yarn'` to the `ALLOWED_COMMANDS` set. Currently it has npm, pnpm, node, npx, git, tsc — yarn is missing but needed for yarn-based projects.

Also, remove `'pnpm-lock.yaml'` and `'package-lock.json'` from `SENSITIVE_PATHS` if present. Package managers need to update these files during installation. (Check if they're currently in the set — they are: line 40-41. They need to be writable by the installer, but the installer uses spawn() directly, not toolkit.writeFile(), so this may not be an issue. Leave them in SENSITIVE_PATHS for now — the installer bypasses toolkit file operations.)
  </action>
  <verify>
Run `pnpm tsc --noEmit` — no type errors. Verify `yarn` is in ALLOWED_COMMANDS. Verify `--auto-install` appears in `agent-helper run --help` output (run `pnpm tsx src/cli/index.ts run --help`).
  </verify>
  <done>
PackageInstaller executes PM commands via spawn() with real-time output. --auto-install flag added to CLI. PipelineOptions includes autoInstall. yarn added to allowed commands.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate installation flow into pipeline import validation loop</name>
  <files>src/orchestrator/pipeline.ts, test/tools/packageInstaller.test.ts</files>
  <action>
**Step 1: Modify the import validation loop in `src/orchestrator/pipeline.ts`.**

The current import validation loop (lines 159-223) detects missing packages and tells the coder to rewrite without them. The new flow must:

1. **At pipeline start** (after gathering project context, before planner): Call `detectPackageManager(tools.getProjectRoot())`. Store result in a variable. If detection returns `err` (multiple lock files), log a warning with the found PMs and skip auto-installation for this run (manual resolution needed). If `ok`, store the detected PM.

2. **Replace the import validation loop logic** (lines 159-223) with an enhanced flow:

   When import validation finds missing packages (`allMissing.length > 0`):

   a. **Registry validation**: Call `validatePackagesBatch(uniqueMissing)` to check all missing packages against npm registry. Split into `registryValid` (exists=true) and `registryInvalid` (exists=false) lists.

   b. **Handle invalid packages**: For packages that failed registry validation, add them to coder feedback as "Package X does not exist on npm registry" with suggested alternatives from SUBSTITUTION_MAP.

   c. **Consent for valid packages**: If `registryValid.length > 0` and a detected package manager exists:
      - If `options.autoInstall` is true, skip consent prompt (per user decision: --auto-install flag skips prompts)
      - Otherwise, use `consentManager.checkBatchApproval()` with enhanced options showing:
        - Package names
        - Reason: "Required by import in generated code"
        - The install command that will run (e.g., "pnpm add zod axios")

   d. **Install approved packages**: Call `installPackages({ packageManager, packages: approved, projectRoot })`.
      - On success: Log installed packages, then **re-run import validation** on the current code changes to verify imports now resolve (per user decision). If imports now resolve, break the retry loop (no need to re-run coder). Update the ImportValidator's allowedPackages set to include newly installed packages.
      - On failure: Add to coder feedback as "Installation failed for X: {error}. Rewrite using alternatives." (per user decision: feed error back to coder)

   e. **Handle rejected packages**: For packages the user rejected, add to coder feedback: "Package X was rejected by user. Rewrite without using this package." (per user decision: feed back to coder to rewrite)

   f. **Re-run coder only if needed**: If all missing packages were successfully installed and imports now resolve, skip coder retry. If there are still unresolved imports (registry-invalid or rejected packages), re-run coder with feedback.

3. **Update ImportValidator to support adding packages**: Add a method or mechanism to update the `allowedPackages` set after successful installation. This could be:
   - A new `addAllowedPackages(packages: string[])` method on ImportValidator
   - Or re-create ImportValidator with updated package list

   Simplest approach: add `addAllowedPackages(packages: string[])` method to ImportValidator class in `src/tools/importValidator.ts`.

   Wait — that file is not in `files_modified` for this plan. The simplest approach is to just create a NEW ImportValidator with the updated package lists after installation, since the constructor takes `(dependencies, devDependencies)`. Reconstruct with: `new ImportValidator([...projectContext.dependencies, ...newlyInstalled], projectContext.devDependencies)`.

**Step 2: Create basic tests for packageInstaller.**

Create `test/tools/packageInstaller.test.ts` with unit tests:
1. Test that `installPackages` with an invalid package name (containing shell metacharacters) returns `err({ type: 'invalid_argument' })`
2. Test that install args are correctly built for each PM:
   - npm: `['install', '--save', 'zod']`
   - pnpm: `['add', 'zod']`
   - yarn: `['add', 'zod']`

For the args test, extract the arg-building logic into a testable exported function `buildInstallArgs(pm: PackageManager, packages: string[]): string[]`.

Do NOT test actual spawn execution in unit tests (requires real PM installed). Integration testing will cover that.
  </action>
  <verify>
Run `pnpm tsc --noEmit` — no type errors. Run `pnpm vitest run test/tools/packageInstaller.test.ts` — unit tests pass. Run `pnpm vitest run` — all existing tests still pass (no regressions).
  </verify>
  <done>
Pipeline import validation loop now: validates packages against registry, prompts for consent (or auto-approves with --auto-install), installs approved packages, re-validates imports after install. Failed/rejected packages feed back to coder for rewriting. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` — no type errors across entire project
2. `pnpm vitest run` — all tests pass (existing + new)
3. Pipeline flow: missing import -> registry check -> consent -> install -> re-validate
4. `--auto-install` flag skips consent prompts
5. Failed installs feed error back to coder
6. Rejected packages feed back to coder
7. yarn is in ALLOWED_COMMANDS
</verification>

<success_criteria>
- End-to-end flow works: detect PM -> find missing imports -> validate against registry -> consent -> install -> re-verify
- --auto-install CLI flag bypasses consent prompts
- Real-time PM output shown to user during installation
- Coder receives actionable feedback for failed/rejected packages
- No regressions in existing tests
- Package manager detection happens once per pipeline run
</success_criteria>

<output>
After completion, create `.planning/phases/01-ecosystem-detection/01-03-SUMMARY.md`
</output>
