---
phase: 01-ecosystem-detection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tools/packageRegistry.ts
  - test/tools/packageRegistry.test.ts
  - src/tools/index.ts
  - package.json
  - pnpm-lock.yaml
autonomous: true

must_haves:
  truths:
    - "Registry client validates real package names as existing (e.g., 'zod' returns true)"
    - "Registry client identifies non-existent packages (e.g., 'zzz-definitely-not-a-real-package-xyz' returns false)"
    - "Registry client rejects invalid package name formats before making HTTP requests"
    - "Registry client handles network errors gracefully without crashing"
    - "Registry client times out after 5 seconds on unresponsive requests"
  artifacts:
    - path: "src/tools/packageRegistry.ts"
      provides: "npm registry validation functions"
      exports: ["validatePackageExists", "validatePackageName", "RegistryValidationResult"]
    - path: "test/tools/packageRegistry.test.ts"
      provides: "Tests for registry validation"
      contains: "describe.*Registry"
  key_links:
    - from: "src/tools/packageRegistry.ts"
      to: "node:https"
      via: "HTTP GET to registry.npmjs.org"
      pattern: "https\\.get.*registry\\.npmjs\\.org"
    - from: "src/tools/packageRegistry.ts"
      to: "validate-npm-package-name"
      via: "Package name format validation"
      pattern: "validate.*package.*name"
---

<objective>
Implement npm registry validation to check if packages exist before showing consent prompts.

Purpose: User decision requires validating packages against npm registry BEFORE consent prompts to prevent typos and hallucinated package names from the Qwen model. This is a safety gate between import detection and installation.
Output: `src/tools/packageRegistry.ts` with `validatePackageExists()` and `validatePackageName()` functions.
</objective>

<execution_context>
@/home/reset/.claude/get-shit-done/workflows/execute-plan.md
@/home/reset/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/utils/result.ts
@.planning/phases/01-ecosystem-detection/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install validate-npm-package-name and implement registry client</name>
  <files>package.json, pnpm-lock.yaml, src/tools/packageRegistry.ts</files>
  <action>
**Step 1: Install dependency.**

Run `pnpm add validate-npm-package-name` and `pnpm add -D @types/validate-npm-package-name` (if types package exists; if not, the package may include its own types - check after install).

Per research: validate-npm-package-name is the official npm library for name validation, handles 50+ edge cases. Do NOT hand-roll package name validation.

**Step 2: Create `src/tools/packageRegistry.ts`.**

Export types:
```typescript
export type RegistryValidationResult = {
  exists: boolean
  error?: string
}

export type PackageNameValidation = {
  valid: boolean
  error?: string
}
```

Implement `validatePackageName(packageName: string): PackageNameValidation`:
- Use `validate-npm-package-name` library
- Return `{ valid: true }` if `validForNewPackages || validForOldPackages`
- Return `{ valid: false, error }` with first error message otherwise

Implement `validatePackageExists(packageName: string): Promise<RegistryValidationResult>`:
1. First call `validatePackageName()` - if invalid, return `{ exists: false, error }` immediately (prevents invalid HTTP requests)
2. Make HTTP GET to `https://registry.npmjs.org/${encodeURIComponent(packageName)}`
3. Set request headers:
   - `Accept: application/vnd.npm.install-v1+json` (abbreviated metadata - 21kB vs 410kB per research)
   - `User-Agent: qwen-coding-agent`
4. Set 5-second timeout on the request
5. Handle responses:
   - 200: `{ exists: true }`
   - 404: `{ exists: false, error: 'Package "X" not found on npm registry' }`
   - Other status: `{ exists: false, error: 'Registry error: HTTP {status}' }`
6. Handle errors:
   - Network error (ENOTFOUND, ETIMEDOUT): `{ exists: false, error: 'Network error: {message}' }`
   - Timeout: `{ exists: false, error: 'Registry request timeout (5s)' }`

Use `node:https` (built-in) for HTTP requests. Do NOT add axios, node-fetch, or any HTTP library (per research: native https sufficient for simple GET).

Drain response body with `res.resume()` - we only need the status code, not the response content.

Implement `validatePackagesBatch(packageNames: string[]): Promise<Map<string, RegistryValidationResult>>`:
- Validate all packages in parallel using `Promise.all`
- Return a Map of package name -> validation result
- This enables batch validation before consent prompt (per user decision: batch all missing packages)
  </action>
  <verify>
Run `pnpm tsc --noEmit` — no type errors. Manually verify `validate-npm-package-name` is in package.json dependencies.
  </verify>
  <done>
`validatePackageExists()` makes HTTP requests to npm registry with 5s timeout. `validatePackageName()` validates format using official library. `validatePackagesBatch()` validates multiple packages in parallel. All use built-in `node:https`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write tests for registry client and export from tools index</name>
  <files>test/tools/packageRegistry.test.ts, src/tools/index.ts</files>
  <action>
**Step 1: Create `test/tools/packageRegistry.test.ts`.**

Test `validatePackageName()` (unit tests, no network):
1. Returns `{ valid: true }` for 'zod' (simple valid name)
2. Returns `{ valid: true }` for '@types/node' (scoped package)
3. Returns `{ valid: false, error }` for '' (empty string)
4. Returns `{ valid: false, error }` for '.invalid' (starts with dot)
5. Returns `{ valid: false, error }` for 'UPPERCASE' (npm requires lowercase)

Test `validatePackageExists()` (integration tests with real network calls):
- Mark these tests with `{ timeout: 10000 }` since they make HTTP requests
- Use `describe('integration')` grouping
6. Returns `{ exists: true }` for 'zod' (well-known real package)
7. Returns `{ exists: false }` for 'zzz-definitely-not-a-real-package-xyz-12345' (non-existent)
8. Returns `{ exists: false, error }` for '.invalid-name' (invalid name caught before HTTP)

Test `validatePackagesBatch()`:
9. Returns results for multiple packages in one call
10. Invalid packages fail without blocking valid ones

**Step 2: Add export to `src/tools/index.ts`.**

Add `export * from './packageRegistry.js'` to `src/tools/index.ts`.

Ensure no export conflicts with existing tools exports.
  </action>
  <verify>
Run `pnpm vitest run test/tools/packageRegistry.test.ts` — all tests pass (requires network connectivity for integration tests). Run `pnpm tsc --noEmit` — no type errors.
  </verify>
  <done>
Registry client has unit tests for name validation and integration tests for registry lookups. All functions exported from tools index. TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
1. `pnpm vitest run test/tools/packageRegistry.test.ts` — all tests pass
2. `pnpm tsc --noEmit` — no type errors
3. `validate-npm-package-name` listed in package.json dependencies
4. Registry validation returns correct results for real and fake packages
</verification>

<success_criteria>
- validatePackageExists() correctly identifies real packages (zod) and rejects fake ones
- validatePackageName() catches invalid package names before HTTP requests
- 5-second timeout prevents hanging on unresponsive registry
- validate-npm-package-name is installed as production dependency
- All functions exported from tools barrel
</success_criteria>

<output>
After completion, create `.planning/phases/01-ecosystem-detection/01-02-SUMMARY.md`
</output>
