---
phase: 03-user-experience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tools/importValidator.ts
  - src/consent/prompter.ts
  - src/consent/manager.ts
  - src/consent/index.ts
  - test/tools/importValidator.test.ts
  - test/consent/prompter.test.ts
  - test/consent/manager.test.ts
autonomous: true

must_haves:
  truths:
    - "SUBSTITUTION_MAP contains structured AlternativeInfo objects with description, module, example, and minNodeVersion"
    - "ImportValidator.validate() returns structured alternative data alongside suggestedFixes for backward compat"
    - "ConsentPrompter displays built-in alternatives with code examples and numbered selection"
    - "ConsentManager.checkBatchApproval returns both approved packages and alternative selections"
    - "User selecting an alternative returns useAlternative with the module name (e.g., node:crypto)"
    - "File context (which files import each package) is displayed in consent prompt"
  artifacts:
    - path: "src/tools/importValidator.ts"
      provides: "Structured SUBSTITUTION_MAP with AlternativeInfo, enhanced validate() returning alternatives"
      exports: ["ImportValidator", "AlternativeInfo", "SUBSTITUTION_MAP"]
    - path: "src/consent/prompter.ts"
      provides: "Enhanced prompt showing structured alternatives with examples, file context, and numbered selection"
      exports: ["ConsentPrompter", "ConsentPromptOptions", "ConsentResponse"]
    - path: "src/consent/manager.ts"
      provides: "Updated checkBatchApproval returning BatchApprovalResult with alternatives map"
      exports: ["ConsentManager", "BatchApprovalResult"]
  key_links:
    - from: "src/tools/importValidator.ts"
      to: "src/consent/prompter.ts"
      via: "AlternativeInfo type flows from SUBSTITUTION_MAP through validate() to prompter options"
      pattern: "AlternativeInfo"
    - from: "src/consent/prompter.ts"
      to: "src/consent/manager.ts"
      via: "useAlternative in ConsentResponse propagated to BatchApprovalResult"
      pattern: "useAlternative"
    - from: "src/consent/manager.ts"
      to: "src/orchestrator/pipeline.ts"
      via: "BatchApprovalResult consumed by pipeline (wired in plan 02)"
      pattern: "BatchApprovalResult"
---

<objective>
Upgrade SUBSTITUTION_MAP to structured AlternativeInfo objects with comprehensive coverage, enhance ConsentPrompter to display alternatives as actionable choices with code examples and file context, and update ConsentManager to propagate alternative selections.

Purpose: Enables the UX layer needed for INST-03 (offer built-in alternatives) and INST-04 (user can choose alternative). This plan builds all the data structures and UI; plan 02 wires them into the pipeline.

Output: Enhanced importValidator.ts, prompter.ts, manager.ts with structured alternatives support and full test coverage.
</objective>

<execution_context>
@/home/reset/.claude/get-shit-done/workflows/execute-plan.md
@/home/reset/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-user-experience/03-RESEARCH.md

@src/tools/importValidator.ts
@src/consent/prompter.ts
@src/consent/manager.ts
@src/consent/schema.ts
@src/consent/index.ts
@test/tools/importValidator.test.ts
@test/consent/prompter.test.ts
@test/consent/manager.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Upgrade SUBSTITUTION_MAP to structured AlternativeInfo and expand coverage</name>
  <files>src/tools/importValidator.ts, test/tools/importValidator.test.ts</files>
  <action>
1. Define and export `AlternativeInfo` type in importValidator.ts:
```typescript
export type AlternativeInfo = {
  description: string   // Human-readable explanation
  module: string        // Built-in module (e.g., 'node:crypto')
  example: string       // Code snippet showing usage
  minNodeVersion: string // Minimum Node.js version required
}
```

2. Convert SUBSTITUTION_MAP from `Record<string, string>` to `Record<string, AlternativeInfo>`. Export it (was previously unexported). Comprehensive entries for Node 20+ stable features:

| Package | Module | Example |
|---------|--------|---------|
| axios | node:https / fetch | `await fetch(url)` |
| node-fetch | node:https / fetch | `await fetch(url)` |
| got | node:https / fetch | `await fetch(url)` |
| request | node:https / fetch | `await fetch(url)` |
| superagent | node:https / fetch | `await fetch(url)` |
| uuid | node:crypto | `crypto.randomUUID()` |
| lodash | Native methods | `Array.prototype.map/filter/reduce` |
| underscore | Native methods | `Array.prototype.map/filter/reduce` |
| fs-extra | node:fs | `fs.cp(src, dest, { recursive: true })` |
| mkdirp | node:fs | `fs.mkdirSync(path, { recursive: true })` |
| rimraf | node:fs | `fs.rmSync(path, { recursive: true })` |
| glob | node:fs | `fs.globSync(pattern)` (Node 22+, use minNodeVersion: '22.0.0') |
| chalk | ANSI codes | `\x1b[31mred text\x1b[0m` |
| colors | ANSI codes | `\x1b[31mred text\x1b[0m` |
| moment | Native Date | `new Intl.DateTimeFormat('en').format(date)` |
| dayjs | Native Date | `new Intl.DateTimeFormat('en').format(date)` |
| path-exists | node:fs | `fs.existsSync(path)` |
| deep-equal | node:util | `util.isDeepStrictEqual(a, b)` |
| depd | node:util | `util.deprecate(fn, msg)` |

3. Add `getAlternative(pkg: string): AlternativeInfo | undefined` method to ImportValidator (public) that looks up SUBSTITUTION_MAP.

4. Update `validate()` to also return `alternatives: Map<string, AlternativeInfo>` alongside existing `suggestedFixes` (keep suggestedFixes for backward compat). The return type becomes:
```typescript
export type ImportValidationResult = {
  valid: boolean
  missingPackages: string[]
  suggestedFixes: string[]  // Keep for backward compat
  alternatives: Map<string, AlternativeInfo>  // NEW: pkg -> alternative info
}
```
For each missing package that has a SUBSTITUTION_MAP entry, add it to `alternatives`.

5. Update `validateWithConsent()` to pass structured alternatives (not string extractions) to checkBatchApproval. The alternatives parameter changes from `string[]` to `AlternativeInfo[]` keyed by package. Update the ConsentManagerLike interface accordingly.

6. Update tests in importValidator.test.ts:
- Existing tests still pass (suggestedFixes still returned).
- Add test: validate() returns `alternatives` map for packages with SUBSTITUTION_MAP entries.
- Add test: validate() returns empty alternatives map for unknown packages.
- Add test: getAlternative() returns AlternativeInfo for known package.
- Add test: getAlternative() returns undefined for unknown package.
- Add test: SUBSTITUTION_MAP has at least 17 entries (coverage check).

Run: `npx vitest run test/tools/importValidator.test.ts`
  </action>
  <verify>npx vitest run test/tools/importValidator.test.ts -- all tests pass including new ones</verify>
  <done>SUBSTITUTION_MAP contains 19+ structured AlternativeInfo entries. validate() returns both suggestedFixes (backward compat) and alternatives Map. getAlternative() works. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Enhance ConsentPrompter with structured alternative display and file context</name>
  <files>src/consent/prompter.ts, src/consent/index.ts, test/consent/prompter.test.ts</files>
  <action>
1. Update ConsentPromptOptions to support structured alternatives and file context:
```typescript
import type { AlternativeInfo } from '../tools/importValidator.js'

export type ConsentPromptOptions = {
  package: string
  reason?: string
  suggestedAlternatives?: string[]  // Keep for backward compat
  alternatives?: AlternativeInfo[]  // NEW: structured alternatives
  fileContext?: string[]  // NEW: files that import this package (e.g., ['src/utils.ts', 'src/api.ts'])
  nonInteractive?: boolean
}
```

2. Update `prompt()` method to display enhanced information:
- Show file context section: "Used in:" followed by each file path if `fileContext` is provided.
- If `alternatives` (structured) is provided, display them with description and example code. Format:
  ```
  Built-in alternatives available:
    1. node:crypto - Use crypto.randomUUID() from node:crypto
       Example: import { randomUUID } from "node:crypto"; const id = randomUUID()
  ```
- Fall back to existing `suggestedAlternatives` display if no structured alternatives.
- Update options display to show `[1-N] Use built-in alternative` when structured alternatives exist.

3. When user selects a numeric option for a structured alternative, return:
```typescript
{ approved: false, scope: 'once', useAlternative: alt.module }
```
Note: `approved: false` because we do NOT want to install the package -- we want to use the built-in instead. This is a change from current behavior where useAlternative returns `approved: true`. The semantic is: "don't install this package, use the alternative instead."

4. Export `AlternativeInfo` type from `src/consent/index.ts` (re-export from importValidator).

5. Update tests:
- Existing non-interactive test still passes.
- Add test: non-interactive mode with alternatives still rejects (alternatives don't override non-interactive).
- Test the ConsentPromptOptions type accepts new fields (TypeScript compilation test via vitest).

Run: `npx vitest run test/consent/prompter.test.ts`
  </action>
  <verify>npx vitest run test/consent/prompter.test.ts -- all tests pass</verify>
  <done>ConsentPrompter displays structured alternatives with examples and file context. Selecting an alternative returns approved:false with useAlternative set. Non-interactive mode unaffected.</done>
</task>

<task type="auto">
  <name>Task 3: Update ConsentManager to propagate alternative selections</name>
  <files>src/consent/manager.ts, src/consent/index.ts, test/consent/manager.test.ts</files>
  <action>
1. Define and export `BatchApprovalResult` type:
```typescript
export type BatchApprovalResult = {
  approved: string[]           // Packages approved for installation
  alternatives: Map<string, string>  // pkg -> alternative module (e.g., 'uuid' -> 'node:crypto')
  rejected: string[]           // Packages explicitly rejected
}
```

2. Add `checkBatchApprovalWithAlternatives()` method to ConsentManager:
```typescript
async checkBatchApprovalWithAlternatives(
  packages: string[],
  options?: {
    alternatives?: Map<string, AlternativeInfo>  // From ImportValidator
    fileContext?: Map<string, string[]>           // From pipeline's packageFileMap
  }
): Promise<BatchApprovalResult>
```
Logic:
- For each package, first check project/session approval (same as existing).
- If not pre-approved, call `this.prompter.prompt()` with:
  - `alternatives`: look up package in options.alternatives, pass as array if found.
  - `fileContext`: look up package in options.fileContext, pass as array.
- If prompter returns `useAlternative`: add to alternatives map, do NOT add to approved.
- If prompter returns `approved: true`: add to approved, record decision (same as existing).
- If prompter returns `approved: false` (reject): add to rejected, stop batch (same as existing).

3. Update existing `checkBatchApproval()` to delegate to the new method for backward compat:
```typescript
async checkBatchApproval(packages: string[], options?: Partial<ConsentPromptOptions>): Promise<string[]> {
  // Backward compat: call new method and return just approved list
  const result = await this.checkBatchApprovalWithAlternatives(packages, {})
  // Old behavior: pass through old-style options to prompter directly for any non-structured calls
  return result.approved
}
```
Wait -- this changes behavior. Let me reconsider. The old checkBatchApproval is called from importValidator.validateWithConsent and from pipeline.ts. To minimize risk:

Keep `checkBatchApproval` exactly as-is. Add the new `checkBatchApprovalWithAlternatives` as a separate method. Pipeline will switch to calling the new method in plan 02. ImportValidator.validateWithConsent continues using the old method (it's not used by pipeline directly anyway -- pipeline calls checkBatchApproval itself).

4. Fix existing `checkApproval` behavior when `useAlternative` is returned: currently it returns `true` which would cause the package to be added to "approved" list and potentially installed. This is wrong. Update `checkApproval` to return `false` when useAlternative is selected (since we don't want to install it). But store the useAlternative value so it can be retrieved. Add a `getLastAlternative(): string | undefined` getter or track alternatives in a map.

Actually, simpler approach: in `checkBatchApprovalWithAlternatives`, handle useAlternative directly without going through `checkApproval`. Call prompter.prompt() directly for packages not pre-approved.

5. Export `BatchApprovalResult` from `src/consent/index.ts`.

6. Update tests:
- Add test: checkBatchApprovalWithAlternatives returns approved packages in approved array.
- Add test: checkBatchApprovalWithAlternatives returns alternative selections in alternatives map (mock prompter to return useAlternative).
- Add test: checkBatchApprovalWithAlternatives returns rejected packages and stops batch on rejection.
- Add test: project-approved packages bypass prompt and go straight to approved.
- Add test: session-approved packages bypass prompt and go straight to approved.
- Existing checkBatchApproval tests still pass unchanged.

Run: `npx vitest run test/consent/manager.test.ts`
  </action>
  <verify>npx vitest run test/consent/manager.test.ts -- all tests pass including new checkBatchApprovalWithAlternatives tests</verify>
  <done>ConsentManager has checkBatchApprovalWithAlternatives() returning BatchApprovalResult with approved, alternatives, and rejected arrays. Existing checkBatchApproval unchanged. All tests pass.</done>
</task>

</tasks>

<verification>
```bash
# All unit tests pass
npx vitest run test/tools/importValidator.test.ts test/consent/prompter.test.ts test/consent/manager.test.ts

# TypeScript compiles
npx tsc --noEmit

# Existing tests not broken
npx vitest run
```
</verification>

<success_criteria>
1. SUBSTITUTION_MAP has 19+ entries with AlternativeInfo objects (description, module, example, minNodeVersion)
2. validate() returns alternatives Map alongside suggestedFixes
3. ConsentPrompter shows structured alternatives with code examples and file context
4. ConsentManager.checkBatchApprovalWithAlternatives returns BatchApprovalResult with approved/alternatives/rejected
5. All existing tests pass (backward compatibility maintained)
6. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-user-experience/03-01-SUMMARY.md`
</output>
