---
phase: 02-dependency-analysis
plan: 03
type: execute
wave: 1
depends_on: []
files_modified: [test/orchestrator/pipeline.test.ts]
autonomous: true
gap_closure: true
must_haves:
  truths:
    - "Pipeline integration tests verify that test-file-only imports install as devDependencies"
    - "Pipeline integration tests verify that production-file imports install as production dependencies"
    - "Pipeline integration tests verify mixed batches separate prod and dev installations"
    - "Pipeline integration tests verify @types/* packages always categorize as dev"
    - "Pipeline integration tests verify packages used in both test and prod files categorize as prod"
  artifacts:
    - path: "test/orchestrator/pipeline.test.ts"
      provides: "5 new pipeline categorization integration tests"
      contains: "categoriz"
  key_links:
    - from: "test/orchestrator/pipeline.test.ts"
      to: "src/orchestrator/pipeline.ts"
      via: "runPipeline calls categorizePackages internally"
      pattern: "categoriz|save-dev|category"
---

<objective>
Add 5 pipeline integration tests that verify the categorized installation behavior introduced in plan 02-02.

Purpose: Close the testing gap identified in verification -- plan 02-02 specified these tests but none were created.
Output: 5 new test cases in test/orchestrator/pipeline.test.ts
</objective>

<execution_context>
@/home/reset/.claude/get-shit-done/workflows/execute-plan.md
@/home/reset/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-dependency-analysis/02-02-SUMMARY.md
@src/orchestrator/pipeline.ts
@test/orchestrator/pipeline.test.ts
@src/tools/dependencyCategorizer.ts
@src/tools/packageInstaller.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 5 pipeline categorization integration tests</name>
  <files>test/orchestrator/pipeline.test.ts</files>
  <action>
Add a new `describe('categorized dependency installation', ...)` block inside the existing `describe('runPipeline', ...)` in test/orchestrator/pipeline.test.ts.

These tests exercise the categorization path in the pipeline (lines 254-312 of pipeline.ts). The pipeline internally calls `categorizePackages()` and then `installPackages()` with `category: 'dev'` or `category: 'prod'`. The tests need to:

1. Mock `detectPackageManager` (from `../../src/tools/packageManager.js`) to return 'npm'
2. Mock `validatePackagesBatch` (from `../../src/tools/packageRegistry.js`) to return exists: true for all packages
3. Mock `installPackages` (from `../../src/tools/packageInstaller.js`) to return ok({ success: true, packages: [...], packageManager: 'npm' })
4. Mock `categorizePackages` (from `../../src/tools/dependencyCategorizer.js`) to return the expected categorization OR let the real implementation run (since the categorizer is pure logic with no I/O -- prefer the real implementation so the test is truly integration-level)

Key mocking approach: Use `vi.mock()` at the top of the file for `packageManager`, `packageRegistry`, and `packageInstaller` modules. Let `categorizePackages` and `ImportValidator` use real implementations. Set `autoInstall: true` in pipeline options to skip consent.

The coder mock should generate code with imports matching the test scenario. The import validator will detect missing packages (not in package.json dependencies). The pipeline will then call categorizePackages with the file paths from the coder output, and then installPackages.

**5 test cases:**

1. "installs test-file-only packages as devDependencies":
   - Coder output: `{ path: 'test/utils.test.ts', content: "import { expect } from 'chai'\nconst x = 1" }`
   - package.json has NO 'chai' dependency
   - Assert: `installPackages` called with `category: 'dev'` and packages including 'chai'
   - Assert: `installPackages` NOT called with `category: 'prod'` (or called with empty packages for prod)

2. "installs production-file packages as production dependencies":
   - Coder output: `{ path: 'src/handler.ts', content: "import express from 'express'\nconst app = express()" }`
   - package.json has NO 'express' dependency
   - Assert: `installPackages` called with `category: 'prod'` and packages including 'express'

3. "separates mixed batch into prod and dev installations":
   - Coder output: two files:
     - `{ path: 'src/app.ts', content: "import lodash from 'lodash'\nconst x = 1" }`
     - `{ path: 'test/app.test.ts', content: "import sinon from 'sinon'\nconst y = 2" }`
   - package.json has neither lodash nor sinon
   - Assert: `installPackages` called twice -- once with category 'prod' containing 'lodash', once with category 'dev' containing 'sinon'

4. "categorizes @types/* packages as dev even from production files":
   - Coder output: `{ path: 'src/types.ts', content: "import type { Request } from '@types/express'\nconst x = 1" }`
   - package.json has NO '@types/express' dependency
   - Assert: `installPackages` called with `category: 'dev'` and packages including '@types/express'

5. "categorizes package as prod when used in both test and prod files":
   - Coder output: two files:
     - `{ path: 'src/validate.ts', content: "import { z } from 'zod'\nconst schema = z.string()" }`
     - `{ path: 'test/validate.test.ts', content: "import { z } from 'zod'\nconst s = z.number()" }`
   - package.json has NO 'zod' dependency
   - Assert: `installPackages` called with `category: 'prod'` and packages including 'zod'

For each test:
- Create mockLLM with generateStructured returning: planner (1 task) -> architect (file plan) -> coder (the imports above) -> reviewer (passed: true)
- Create mockToolKit with readFile returning a package.json that does NOT include the tested packages
- Pass `autoInstall: true` to runPipeline options
- Verify installPackages mock call arguments for correct category

Important: The existing tests do NOT mock these modules. Add `vi.mock()` calls at the top of the file for the 3 modules (packageManager, packageRegistry, packageInstaller). Use `vi.hoisted()` for the mock functions so they work with ESM hoisting. In the new describe block, set up the mocks in a `beforeEach`. In the existing tests' `beforeEach`, ensure the mocks return safe defaults (detectPackageManager returns null so the categorization path is skipped for existing tests).

Actually, a cleaner approach: use `vi.mock()` with per-test overrides via `vi.mocked().mockReturnValue()` in the new describe block only. The mocked modules will return `undefined` by default which won't break existing tests since they don't hit the installation path (their coder output uses valid imports or they test error paths).

Verify all existing tests still pass after adding mocks.
  </action>
  <verify>
Run `npx vitest run test/orchestrator/pipeline.test.ts` -- all existing tests plus 5 new tests pass. Total should be 10 tests (5 existing + 5 new).
  </verify>
  <done>
5 new integration tests verify: (1) test-only packages install as dev, (2) production packages install as prod, (3) mixed batches separate correctly, (4) @types/* always dev, (5) both-context packages install as prod. All 10 tests in file pass.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run test/orchestrator/pipeline.test.ts` passes with 10 tests
- New tests are in a `describe('categorized dependency installation', ...)` block
- Each test verifies `installPackages` call arguments for correct `category` value
- Existing 5 tests remain unchanged and passing
</verification>

<success_criteria>
- 5 new tests cover all gap items from VERIFICATION.md
- All 10 tests pass (5 existing + 5 new)
- No production code changes required
- Tests exercise the real categorizePackages logic through the pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/02-dependency-analysis/02-03-SUMMARY.md`
</output>
