---
phase: 02-dependency-analysis
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/orchestrator/pipeline.ts
  - src/tools/index.ts
  - test/orchestrator/pipeline.test.ts
autonomous: true

must_haves:
  truths:
    - "Pipeline categorizes missing packages before installation"
    - "Dev packages are installed with --save-dev/-D flags"
    - "Production packages are installed with --save flags"
    - "Installed dev packages update devDependencies in ImportValidator rebuild"
    - "Pipeline handles mixed batches (some prod, some dev) in a single import validation pass"
  artifacts:
    - path: "src/orchestrator/pipeline.ts"
      provides: "Categorization integrated into import validation loop"
      contains: "categorizePackages"
    - path: "src/tools/index.ts"
      provides: "Re-exports dependency categorizer"
      contains: "dependencyCategorizer"
    - path: "test/orchestrator/pipeline.test.ts"
      provides: "Tests verifying categorized installation behavior"
      contains: "categoriz"
  key_links:
    - from: "src/orchestrator/pipeline.ts"
      to: "src/tools/dependencyCategorizer.ts"
      via: "import categorizePackages"
      pattern: "import.*categorizePackages.*dependencyCategorizer"
    - from: "src/orchestrator/pipeline.ts"
      to: "src/tools/packageInstaller.ts"
      via: "installPackages called twice (prod + dev) or with category"
      pattern: "installPackages"
---

<objective>
Integrate dependency categorization into the pipeline's import validation loop so that missing packages are automatically categorized as production or dev before installation, and installed with the correct flags.

Purpose: Without this integration, all missing packages are installed as production dependencies. This plan wires the categorization logic from Plan 01 into the pipeline so test-only packages go to devDependencies automatically.

Output: Updated pipeline with categorized installation + barrel export + integration tests.
</objective>

<execution_context>
@/home/reset/.claude/get-shit-done/workflows/execute-plan.md
@/home/reset/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-dependency-analysis/02-RESEARCH.md
@.planning/phases/02-dependency-analysis/02-01-SUMMARY.md
@src/orchestrator/pipeline.ts
@src/tools/packageInstaller.ts
@src/tools/dependencyCategorizer.ts
@src/tools/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate categorization into pipeline import validation loop</name>
  <files>
    src/orchestrator/pipeline.ts
    src/tools/index.ts
  </files>
  <action>
**1. Add barrel export** in `src/tools/index.ts`:
Add re-export for `dependencyCategorizer` module (follow existing pattern in the file).

**2. Update pipeline.ts imports:**
Add import for `categorizePackages` and `CategorizedPackages` from `../tools/dependencyCategorizer.js`.

**3. Modify the import validation loop** (around lines 206-291 in pipeline.ts):

Currently, after registry validation and consent, ALL approved packages are installed in one `installPackages()` call with no category. Change this to:

a. **Build file context for categorization:** When collecting missing packages from `codeResult.value.changes`, also track WHICH files import each package. Create a map: `Map<string, string[]>` mapping package name → array of file paths that import it.

To do this, modify the inner loop (lines 187-194) that iterates over changes and calls `importValidator.validate()`. For each change with missing packages, record `change.path` as an importing file for each missing package.

b. **Categorize after consent, before install:** After `approved` list is determined, call:
```typescript
const entries = approved.map(pkg => ({
  name: pkg,
  files: packageFileMap.get(pkg) ?? []
}))
const categorized = categorizePackages(entries)
```

c. **Install in two passes (sequential):** Replace the single `installPackages()` call with:
```typescript
const allInstalled: string[] = []

// Install production packages first
if (categorized.production.length > 0) {
  const prodResult = await installPackages({
    packageManager: detectedPM,
    packages: categorized.production,
    projectRoot: tools.getProjectRoot(),
    category: 'prod',
  })
  if (prodResult.ok) {
    allInstalled.push(...categorized.production)
  } else {
    // Handle failure same as current code
  }
}

// Install dev packages
if (categorized.dev.length > 0) {
  const devResult = await installPackages({
    packageManager: detectedPM,
    packages: categorized.dev,
    projectRoot: tools.getProjectRoot(),
    category: 'dev',
  })
  if (devResult.ok) {
    allInstalled.push(...categorized.dev)
  } else {
    // Handle failure same as current code
  }
}
```

d. **Update installPackages to accept category:** Add optional `category` field to the `installPackages` options object. Pass it through to `buildInstallArgs`. Default to `'prod'` for backward compat.

Update `src/tools/packageInstaller.ts` — add `category?: 'dev' | 'prod'` to the options type and pass it to `buildInstallArgs`:
```typescript
const args = buildInstallArgs(packageManager, packages, options.category ?? 'prod')
```

e. **Fix ImportValidator rebuild:** Currently (line 261-264), installed packages are always added to `dependencies` list. Fix to track prod and dev separately:
```typescript
// Track installed packages by category
const installedProd: string[] = []
const installedDev: string[] = []

// After successful prod install:
installedProd.push(...categorized.production)

// After successful dev install:
installedDev.push(...categorized.dev)

// Rebuild validator:
importValidator = new ImportValidator(
  [...projectContext.dependencies, ...installedProd],
  [...projectContext.devDependencies, ...installedDev]
)
```

Move the `installedPackages` tracking to use two arrays (`installedProd`, `installedDev`) instead of one, initialized before the task loop.

f. **Update consent message:** The install command shown to the user in the consent prompt (line 232) should reflect the category. Show two commands if there are both prod and dev packages, or the appropriate single command.

**Important:** Keep the sequential nature of prod-then-dev installation to avoid lock file race conditions (anti-pattern from research).

**Important:** The `installPackages` function signature change (adding `category`) is backward compatible since the field is optional with a default.
  </action>
  <verify>
1. `npx tsc --noEmit` — TypeScript compiles
2. `npx vitest run test/orchestrator/pipeline.test.ts` — existing pipeline tests pass
3. `npx vitest run` — full suite passes
  </verify>
  <done>Pipeline categorizes packages before installation. Production packages get --save flags, dev packages get --save-dev/-D. ImportValidator rebuild correctly tracks prod vs dev installed packages. Consent message shows appropriate install commands.</done>
</task>

<task type="auto">
  <name>Task 2: Add pipeline integration tests for categorized installation</name>
  <files>
    test/orchestrator/pipeline.test.ts
  </files>
  <action>
Add integration tests to `test/orchestrator/pipeline.test.ts` that verify the categorization integration. These tests should use the existing test patterns/mocks in the file.

**Test cases to add:**

1. **Test: packages imported only in test files are installed as dev dependencies**
   - Mock coder output with a change at path `test/user.test.ts` that imports `vitest`
   - Mock registry validation returning valid for `vitest`
   - Mock consent manager approving `vitest`
   - Verify `installPackages` is called with `category: 'dev'`

2. **Test: packages imported in production files are installed as production dependencies**
   - Mock coder output with a change at path `src/user.ts` that imports `zod`
   - Verify `installPackages` is called with `category: 'prod'`

3. **Test: mixed batch separates prod and dev installations**
   - Mock coder output with changes at `src/app.ts` (imports `express`) and `test/app.test.ts` (imports `supertest`)
   - Verify two separate `installPackages` calls: one with `category: 'prod'` for `express`, one with `category: 'dev'` for `supertest`

4. **Test: @types/* packages always categorized as dev even from production file**
   - Mock coder output at `src/server.ts` importing `@types/express`
   - Verify installed with `category: 'dev'`

5. **Test: package used in both test and prod files categorized as prod**
   - Mock coder output: `src/schema.ts` imports `zod`, `test/schema.test.ts` also imports `zod`
   - Verify `installPackages` called with `category: 'prod'` for `zod`

Follow existing test patterns in the file. Use `vi.mock` for `installPackages` and `categorizePackages` if needed, or test through the real functions depending on existing test setup.
  </action>
  <verify>Run `npx vitest run test/orchestrator/pipeline.test.ts` — all tests pass including new categorization tests.</verify>
  <done>Integration tests verify that pipeline correctly categorizes and installs packages with appropriate flags. Mixed batches, @types/*, known dev packages, and prod-used-in-test-too scenarios all tested.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — full TypeScript compilation succeeds
2. `npx vitest run` — all tests pass (unit + integration)
3. Manual inspection: pipeline.ts imports categorizePackages and uses it before installPackages
4. Manual inspection: installPackages options include category parameter
5. Manual inspection: ImportValidator rebuild uses separate prod/dev tracking
</verification>

<success_criteria>
- Pipeline categorizes packages before installation using file path context
- Production packages installed with --save (npm) / add (pnpm/yarn)
- Dev packages installed with --save-dev (npm) / -D (pnpm) / --dev (yarn)
- ImportValidator rebuild tracks prod and dev installed packages separately
- Mixed batches (some prod, some dev) handled correctly in single pipeline pass
- All existing pipeline tests continue to pass (no regressions)
- New integration tests cover categorization scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/02-dependency-analysis/02-02-SUMMARY.md`
</output>
